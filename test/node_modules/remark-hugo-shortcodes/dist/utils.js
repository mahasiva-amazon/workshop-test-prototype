"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isShortcodeAST = exports.isRemarkCompiler = exports.isRemarkParser = exports.escapeAttribute = exports.parseParam = exports.parsePlainParam = exports.cleanCurly = void 0;
function cleanCurly(val) {
    if (Array.isArray(val))
        val = val.map(cleanCurly);
    else if (val && typeof val == 'object') {
        Object.keys(val).forEach(k => val[k] = cleanCurly(val[k]));
    }
    else if (typeof val == 'string') {
        val = val
            .replace(/[’′]/g, "'")
            .replace(/[“”″]/g, '"')
            .replace(/–/g, '--')
            .replace(/—/g, '---')
            .replace(/…/g, '...');
    }
    return val;
}
exports.cleanCurly = cleanCurly;
function parsePlainParam(value, endBlock, trimValue = false, asValue = false) {
    var _a, _b;
    const matches = [
        /\s/m.exec(value),
        asValue ? undefined : /=/.exec(value),
        /\//.exec(value),
        new RegExp(endBlock.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).exec(value)
    ];
    const index = matches
        .map(m => { var _a; return (_a = m === null || m === void 0 ? void 0 : m.index) !== null && _a !== void 0 ? _a : -1; })
        .reduce((t, i) => Math.min(t, i) >= 0 ? Math.min(t, i) : Math.max(t, i), -1);
    if (index < 0) {
        return {
            param: value.trim(),
            value: ''
        };
    }
    else {
        const param = value.substr(0, index);
        value = value.substr(index).trimLeft();
        if (trimValue && value.charAt(0) === '=') {
            const i = (_b = (_a = /\s/m.exec(value)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
            value = i >= 0
                ? value.substr(i).trimLeft()
                : '';
        }
        return {
            param,
            value
        };
    }
}
exports.parsePlainParam = parsePlainParam;
function parseParam(value, endBlock, asValue = false) {
    var _a, _b;
    const t = value.charAt(0);
    if (!escapingTokensSet.has(t)) {
        return parsePlainParam(value, endBlock, false, asValue);
    }
    else {
        value = value.substr(1);
        const i = (_b = (_a = new RegExp(`(^|[^\\\\])${t}`).exec(value)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
        if (i < 0)
            return {
                param: value.replace(new RegExp(`\\\\${t}`, 'g'), t),
                value: ''
            };
        else
            return {
                param: value.substr(0, i + 1).replace(new RegExp(`\\\\${t}`, 'g'), t),
                value: value.substr(i + 2).trimLeft()
            };
    }
}
exports.parseParam = parseParam;
const escapingTokens = ['"', '`'];
const escapingTokensSet = new Set(escapingTokens);
function escapeAttribute(attr, forceQuotes = false) {
    const hasTokens = !!escapingTokens.find(t => attr.indexOf(t) >= 0);
    const freeToken = escapingTokens.find(t => attr.indexOf(t) < 0);
    const hasNewLine = attr.indexOf('\n') >= 0;
    const needsEscape = forceQuotes || hasTokens || !attr.match(/^[a-z0-9]+$/);
    if (hasNewLine)
        return '`' + attr.replace(/`/g, '\\`') + '`';
    if (hasTokens && freeToken)
        return freeToken + attr + freeToken;
    if (needsEscape)
        return '"' + attr.replace(/"/g, '\\"') + '"';
    return attr;
}
exports.escapeAttribute = escapeAttribute;
function isRemarkParser(parser) {
    var _a, _b, _c;
    return !!((_c = (_b = (_a = parser === null || parser === void 0 ? void 0 : parser.prototype) === null || _a === void 0 ? void 0 : _a.inlineTokenizers) === null || _b === void 0 ? void 0 : _b.break) === null || _c === void 0 ? void 0 : _c.locator);
}
exports.isRemarkParser = isRemarkParser;
function isRemarkCompiler(compiler) {
    return !!(compiler === null || compiler === void 0 ? void 0 : compiler.prototype);
}
exports.isRemarkCompiler = isRemarkCompiler;
function isShortcodeAST(node) {
    return node.type === 'shortcode';
}
exports.isShortcodeAST = isShortcodeAST;
//# sourceMappingURL=utils.js.map