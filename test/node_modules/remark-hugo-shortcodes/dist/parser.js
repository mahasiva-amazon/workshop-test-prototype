"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenizer = void 0;
const remark_1 = __importDefault(require("remark"));
const remark_preset_lint_markdown_style_guide_1 = __importDefault(require("remark-preset-lint-markdown-style-guide"));
const utils_1 = require("./utils");
const rm = remark_1.default()
    .use(remark_preset_lint_markdown_style_guide_1.default);
function getTokenizer(tokens, markdownAttributes) {
    function shortcodeTokenizer(eat, value, silent) {
        const matchingTokens = tokens.find(([start]) => value.startsWith(start));
        if (!matchingTokens)
            return;
        const [startBlock, endBlock] = matchingTokens;
        let remainingValue = value.substr(startBlock.length).trimLeft();
        const closing = remainingValue.startsWith('/');
        if (closing)
            remainingValue = remainingValue.substr(1).trimLeft();
        const parsedName = utils_1.parsePlainParam(remainingValue, endBlock, true);
        if (!parsedName)
            return;
        const identifier = parsedName.param;
        remainingValue = parsedName.value.trimLeft();
        let selfClosing = false;
        const attributes = [];
        let kv = [];
        let ended = false;
        while (remainingValue.length) {
            if (remainingValue.indexOf('/') == 0) {
                selfClosing = true;
                remainingValue = remainingValue.substr(1).trimLeft();
            }
            if (remainingValue.indexOf(endBlock) == 0) {
                remainingValue = remainingValue.substr(endBlock.length);
                ended = true;
                break;
            }
            if (remainingValue.indexOf('=') == 0) {
                remainingValue = remainingValue.substr(1).trimLeft();
            }
            const parsedParam = utils_1.parseParam(remainingValue, endBlock, kv.length == 1);
            kv.push(parsedParam.param);
            remainingValue = parsedParam.value.trimLeft();
            if (kv.length == 2 || remainingValue.charAt(0) != '=') {
                attributes.push(kv);
                kv = [];
            }
        }
        if (kv.length)
            attributes.push(kv);
        if (!ended)
            return;
        if (silent) {
            return true;
        }
        const entireShortcode = value.substr(0, value.length - remainingValue.length);
        attributes.forEach(attr => {
            if (attr.length == 2 && markdownAttributes.has(attr[0].toLowerCase()))
                attr[1] = utils_1.cleanCurly(String(rm.processSync('' + (attr[1] || ''))).trim());
        });
        return eat(entireShortcode)({
            type: 'shortcode',
            identifier,
            attributes: closing ? [] : attributes,
            closing,
            selfClosing: closing ? false : selfClosing,
            startBlock,
            endBlock
        });
    }
    shortcodeTokenizer.locator = function locator(value, fromIndex) {
        let i = -1;
        tokens.forEach(([start]) => {
            const m = value.indexOf(start, fromIndex);
            if (m >= 0 && (i < 0 || m < i))
                i = m;
        });
        return i;
    };
    return shortcodeTokenizer;
}
exports.getTokenizer = getTokenizer;
//# sourceMappingURL=parser.js.map