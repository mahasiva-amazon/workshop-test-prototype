{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { PartialRemarkOptions } from 'remark'\n// tslint:disable-next-line: no-implicit-dependencies\nimport { Parser } from 'remark-parse'\n// tslint:disable-next-line: no-implicit-dependencies\nimport { Compiler } from 'remark-stringify'\n// tslint:disable-next-line: no-implicit-dependencies\nimport { Processor } from 'unified'\n// tslint:disable-next-line: no-implicit-dependencies\nimport { Node } from 'unist'\n\n/**\n * Recursively replace pretty UTF quotes and dashes with corresponding straight ones.\n */\nexport function cleanCurly<T>(val: T[]): T[]\nexport function cleanCurly<T>(val: T): T\nexport function cleanCurly<T>(val: T): T {\n    if (Array.isArray(val))\n        val = val.map(cleanCurly) as any\n    else if (val && typeof val == 'object') {\n        Object.keys(val).forEach(k => (val as any)[k] = cleanCurly((val as any)[k]))\n    } else if (typeof val == 'string') {\n        val = val\n            .replace(/[’′]/g, \"'\")\n            .replace(/[“”″]/g, '\"')\n            .replace(/–/g, '--')\n            .replace(/—/g, '---')\n            .replace(/…/g, '...') as any\n    }\n    return val\n}\n\nexport interface ShortcodeAST extends Node {\n    type: 'shortcode'\n    identifier: string\n    attributes: Array<[string] | [string, string]>\n    closing: boolean\n    selfClosing: boolean\n    startBlock: string\n    endBlock: string\n}\n\nexport interface ParamParseResult {\n    param: string\n    value: string\n}\n\nexport function parsePlainParam(value: string, endBlock: string, trimValue = false, asValue = false): ParamParseResult {\n    const matches = [\n        /\\s/m.exec(value),\n        asValue ? undefined : /=/.exec(value),\n        /\\//.exec(value),\n        new RegExp(endBlock.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).exec(value)\n    ]\n\n    const index = matches\n        .map(m => m?.index ?? -1)\n        .reduce((t, i) => Math.min(t, i) >= 0 ? Math.min(t, i) : Math.max(t, i), -1)\n\n    if (index < 0) {\n        return {\n            param: value.trim(),\n            value: ''\n        }\n    } else {\n        const param = value.substr(0, index)\n        value = value.substr(index).trimLeft()\n        if (trimValue && value.charAt(0) === '=') {\n            const i = /\\s/m.exec(value)?.index ?? -1\n            value = i >= 0\n                ? value.substr(i).trimLeft()\n                : ''\n        }\n        return {\n            param,\n            value\n        }\n    }\n}\n\nexport function parseParam(value: string, endBlock: string, asValue = false): ParamParseResult {\n    const t = value.charAt(0)\n    if (!escapingTokensSet.has(t)) {\n        return parsePlainParam(value, endBlock, false, asValue)\n    } else {\n        value = value.substr(1)\n        const i = new RegExp(`(^|[^\\\\\\\\])${t}`).exec(value)?.index ?? -1\n        if (i < 0)\n            return {\n                param: value.replace(new RegExp(`\\\\\\\\${t}`, 'g'), t),\n                value: ''\n            }\n        else\n            return {\n                param: value.substr(0, i + 1).replace(new RegExp(`\\\\\\\\${t}`, 'g'), t),\n                value: value.substr(i + 2).trimLeft()\n            }\n    }\n}\n\nconst escapingTokens = ['\"', '`']\nconst escapingTokensSet = new Set(escapingTokens)\n\nexport function escapeAttribute(attr: string, forceQuotes = false) {\n    const hasTokens = !!escapingTokens.find(t => attr.indexOf(t) >= 0)\n    const freeToken = escapingTokens.find(t => attr.indexOf(t) < 0)\n    const hasNewLine = attr.indexOf('\\n') >= 0\n    const needsEscape = forceQuotes || hasTokens || !attr.match(/^[a-z0-9]+$/)\n\n    if (hasNewLine)\n        return '`' + attr.replace(/`/g, '\\\\`') + '`'\n\n    if (hasTokens && freeToken)\n        return freeToken + attr + freeToken\n\n    if (needsEscape)\n        return '\"' + attr.replace(/\"/g, '\\\\\"') + '\"'\n\n    return attr\n}\n\nexport function isRemarkParser(parser?: Processor<PartialRemarkOptions>['Parser']): parser is typeof Parser {\n    return !!parser?.prototype?.inlineTokenizers?.break?.locator\n}\n\nexport function isRemarkCompiler(compiler: Processor<PartialRemarkOptions>['Compiler']): compiler is typeof Compiler {\n    return !!compiler?.prototype\n}\n\nexport function isShortcodeAST(node: Node): node is ShortcodeAST {\n    return node.type === 'shortcode'\n}\n"]}