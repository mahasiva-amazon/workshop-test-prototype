{"version":3,"file":"parser.js","sourceRoot":"","sources":["../src/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import remark from 'remark'\n// tslint:disable-next-line: no-implicit-dependencies\nimport { Eat, Tokenizer } from 'remark-parse'\nimport guide from 'remark-preset-lint-markdown-style-guide'\n// tslint:disable-next-line: no-implicit-dependencies\nimport { Node } from 'unist'\nimport { cleanCurly, parseParam, parsePlainParam, ShortcodeAST } from './utils'\n\nconst rm = remark()\n    .use(guide)\n\nexport function getTokenizer(tokens: Array<[string, string]>, markdownAttributes: Set<string>): Tokenizer {\n    function shortcodeTokenizer(eat: Eat, value: string, silent: true): boolean | void\n    function shortcodeTokenizer(eat: Eat, value: string): Node | void\n    function shortcodeTokenizer(eat: Eat, value: string, silent?: true): Node | boolean | void {\n        const matchingTokens = tokens.find(([start]) => value.startsWith(start))\n        if (!matchingTokens)\n            return\n\n        const [startBlock, endBlock] = matchingTokens\n\n        let remainingValue = value.substr(startBlock.length).trimLeft()\n        const closing = remainingValue.startsWith('/')\n        if (closing)\n            remainingValue = remainingValue.substr(1).trimLeft()\n\n        const parsedName = parsePlainParam(remainingValue, endBlock, true)\n        if (!parsedName)\n            return\n\n        const identifier = parsedName.param\n        remainingValue = parsedName.value.trimLeft()\n\n        let selfClosing = false\n        const attributes = []\n        let kv = []\n        let ended = false\n        while (remainingValue.length) {\n            if (remainingValue.indexOf('/') == 0) {\n                selfClosing = true\n                remainingValue = remainingValue.substr(1).trimLeft()\n            }\n            if (remainingValue.indexOf(endBlock) == 0) {\n                remainingValue = remainingValue.substr(endBlock.length)\n                ended = true\n                break\n            }\n            if (remainingValue.indexOf('=') == 0) {\n                remainingValue = remainingValue.substr(1).trimLeft()\n            }\n\n            const parsedParam = parseParam(remainingValue, endBlock, kv.length == 1)\n            kv.push(parsedParam.param)\n            remainingValue = parsedParam.value.trimLeft()\n            if (kv.length == 2 || remainingValue.charAt(0) != '=') {\n                attributes.push(kv)\n                kv = []\n            }\n        }\n        if (kv.length)\n            attributes.push(kv)\n\n        if (!ended)\n            return\n\n        if (silent) {\n            return true\n        }\n\n        const entireShortcode = value.substr(0, value.length - remainingValue.length)\n\n        attributes.forEach(attr => {\n            if (attr.length == 2 && markdownAttributes.has(attr[0].toLowerCase()))\n                attr[1] = cleanCurly(String(rm.processSync('' + (attr[1] || ''))).trim())\n        })\n\n        return eat(entireShortcode)({\n            type: 'shortcode',\n            identifier,\n            attributes: closing ? [] : attributes,\n            closing,\n            selfClosing: closing ? false : selfClosing,\n            startBlock,\n            endBlock\n        } as ShortcodeAST)\n    }\n\n    shortcodeTokenizer.locator = function locator(value: string, fromIndex?: number) {\n        let i = -1\n        tokens.forEach(([start]) => {\n            const m = value.indexOf(start, fromIndex)\n            if (m >= 0 && (i < 0 || m < i))\n                i = m\n        })\n        return i\n    }\n\n    return shortcodeTokenizer\n}\n"]}